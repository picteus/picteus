import {
  Communicator,
  GenerationRecipe,
  Helper,
  ImageFeatureFormat,
  ImageFeatureType,
  ImageMetadata,
  NotificationEvent,
  NotificationValue,
  PicteusExtension,
  PromptKind,
  SettingsValue
} from "@picteus/extension-sdk";


enum Automatic1111Constants
{
  userComment = "userComment",
  parameters = "parameters"
}

class Automatic1111Instruction
{

  constructor(key: string, value: string)
  {
    this.key = key;
    this.value = value;
  }

  readonly key: string;

  readonly value: string;

}

/**
 * The instructions of an image generated by Automatic1111.
 */
export class Automatic1111UserComment
{

  static parse(userCommentOrParameters: string): Automatic1111UserComment
  {
    const elements = Automatic1111UserComment.extractUserComment(userCommentOrParameters);
    if (elements === undefined)
    {
      throw new Error("The image does not contain valid Automatic1111 metadata");
    }
    const { positive, negative, rest } = elements;
    const instructions: Automatic1111Instruction[] = [];
    const addInstruction = (key: string, value: string): void =>
    {
      instructions.push(new Automatic1111Instruction(key, value));
    };
    if (rest !== "")
    {
      let string = rest;
      while (true)
      {
        const result1 = /^([^"^:]*): .*$/m.exec(string);
        if (result1 !== null)
        {
          const key = result1[1];
          string = string.substring(key.length + 2);
          const result2 = /^([^"^:]*): .*$/m.exec(string);
          if (result2 !== null)
          {
            const value = result2[1].substring(0, result2[1].lastIndexOf(","));
            addInstruction(key, value);
            string = string.substring(value.length + 2);
          }
          else
          {
            const result3 = /^(.*?), ([^"^:]*): .*$/m.exec(string);
            if (result3 !== null)
            {
              const value = result3[1];
              addInstruction(key, value);
              string = string.substring(value.length + 2);
            }
            else
            {
              addInstruction(key, string);
              break;
            }
          }
        }
        else
        {
          throw new Error(`Unexpected '${Automatic1111Constants.userComment}' or '${Automatic1111Constants.parameters}' format`);
        }
      }
    }
    return new Automatic1111UserComment(positive, negative, instructions);
  }

  static extractUserComment(userCommentOrParameters: string): {
    positive: string,
    negative: string | undefined,
    unexpected: string | undefined,
    rest: string
  } | undefined
  {
    let positive: string;
    let negative: string | undefined;
    let unexpected: string | undefined;
    let rest: string;
    {
      const newLine = "\n";
      const negativePromptCoreMarker = "Negative prompt:";
      const negativePromptMarker = `${newLine}${negativePromptCoreMarker}`;
      const negativePromptIndex = userCommentOrParameters.indexOf(negativePromptMarker);
      if (negativePromptIndex !== -1)
      {
        positive = userCommentOrParameters.substring(0, negativePromptIndex).trim();
        const remainingString = userCommentOrParameters.substring(negativePromptIndex + negativePromptMarker.length);
        const result = /^(.*)\n[^:\n]*: .*$/sm.exec(remainingString);
        negative = (result === null ? remainingString : result[1]).trim();
        rest = result === null ? "" : remainingString.substring(result[1].length + 1);
      }
      else
      {
        const tokens = userCommentOrParameters.split(newLine);
        if (tokens.length === 1)
        {
          // This does not correspond to a valid Automatic1111 generated image. This happens in the case of an image generated by ReActor, https://github.com/Gourieff/sd-webui-reactor
          return undefined;
        }
        else
        {
          let index = 0;
          positive = tokens[index++];
          if (tokens.length >= 3)
          {
            negative = tokens[index++];
            unexpected = tokens.slice(index++, tokens.length - 1).join(newLine);
          }
          rest = tokens[tokens.length - 1];
        }
      }
    }
    return { positive, negative, unexpected, rest };
  }

  constructor(positive: string, negative: string | undefined, instructions: Automatic1111Instruction[])
  {
    this.positive = positive;
    this.negative = negative;
    this.instructions = instructions;
  }

  readonly positive: string;

  readonly negative?: string;

  readonly instructions: Automatic1111Instruction[];

}


class Automatic1111Extension extends PicteusExtension
{

  protected async onReady(communicator?: Communicator): Promise<void>
  {
    await this.setup(communicator!, await this.getSettings());
  }

  protected async onSettings(communicator: Communicator, value: SettingsValue): Promise<void>
  {
    await this.setup(communicator, value);
  }

  protected async onEvent(_communicator: Communicator, event: string, value: NotificationValue): Promise<any>
  {
    if (event === NotificationEvent.ImageCreated || event === NotificationEvent.ImageUpdated || event === NotificationEvent.ImageComputeTags || event === NotificationEvent.ImageComputeFeatures)
    {
      const imageId: string = value["id"];
      const metadata = await this.getImageApi().imageGetMetadata({ id: imageId });
      if (event === NotificationEvent.ImageCreated || event === NotificationEvent.ImageUpdated || event === NotificationEvent.ImageComputeTags)
      {
        await this.computeTags(imageId, metadata);
      }
      if (event === NotificationEvent.ImageCreated || event === NotificationEvent.ImageUpdated || event === NotificationEvent.ImageComputeFeatures)
      {
        await this.computeFeatures(imageId, metadata);
      }
    }
  }

  private async setup(_communicator: Communicator, _value: SettingsValue): Promise<void>
  {
  }

  private async computeTags(imageId: string, metadata: ImageMetadata): Promise<void>
  {
    const userComment = this.computeUserComment(metadata);
    await this.getImageApi().imageSetTags({
      id: imageId,
      extensionId: this.extensionId,
      requestBody: userComment !== undefined ? [this.extensionId] : []
    });
  }

  private async computeFeatures(imageId: string, metadata: ImageMetadata): Promise<void>
  {
    const userComment: Automatic1111UserComment | undefined = this.computeUserComment(metadata);
    if (userComment !== undefined)
    {
      const recipe: GenerationRecipe =
        {
          schemaVersion: Helper.GENERATION_RECIPE_SCHEMA_VERSION,
          modelTags: [],
          software: "automatic1111",
          prompt: { kind: PromptKind.Instructions, value: userComment }
        };
      await this.getImageApi().imageSetFeatures({
        id: imageId,
        extensionId: this.extensionId,
        imageFeature: [
          {
            type: ImageFeatureType.Recipe,
            format: ImageFeatureFormat.Json,
            value: JSON.stringify(recipe)
          }
        ]
      });
    }
  }

  private computeUserComment(metadata: ImageMetadata): Automatic1111UserComment | undefined
  {
    if (metadata.all !== undefined)
    {
      const allMetadata = JSON.parse(metadata.all);
      const userComment: string | undefined = allMetadata[Automatic1111Constants.userComment];
      try
      {
        return Automatic1111UserComment.parse(userComment === undefined ? allMetadata[Automatic1111Constants.parameters] : userComment);
      }
      catch (error)
      {
        // It means that this is not an Automatic1111 generated image
      }
    }
    return undefined;
  }

}

new Automatic1111Extension().run().catch((error) =>
{
  console.error(error);
  throw error;
});
